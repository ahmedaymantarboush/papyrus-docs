<?php

namespace AhmedTarboush\PapyrusDocs\Exporters;

/**
 * OpenApiGenerator — Converts the Papyrus internal schema into
 * a valid OpenAPI 3.0 JSON specification.
 *
 * Uses config('papyrus.open_api') for:
 *   - title, description, version, document_version
 *   - license, server_url
 *   - security scheme
 *   - default responses
 *   - delete_with_body, exclude_http_methods
 */
class OpenApiGenerator
{
    /**
     * Generate a complete OpenAPI 3.0 specification.
     *
     * @param  mixed  $schema  The grouped routes collection from PapyrusGenerator::scan()
     * @return array  OpenAPI 3.0 spec array
     */
    public function generate($schema): array
    {
        $cfg = config('papyrus.open_api', []);

        $spec = [
            'openapi' => $cfg['version'] ?? '3.0.0',
            'info'    => [
                'title'       => $cfg['title'] ?? config('papyrus.title', config('app.name') . ' API'),
                'description' => $cfg['description'] ?? 'API documentation auto-generated by Papyrus Docs.',
                'version'     => $cfg['document_version'] ?? '1.0.0',
                'license'     => [
                    'name' => $cfg['license'] ?? 'Apache 2.0',
                ],
            ],
            'servers' => [
                ['url' => $cfg['server_url'] ?? config('app.url', 'http://localhost')],
            ],
            'paths'      => $this->buildPaths($schema, $cfg),
            'components' => $this->buildComponents($cfg),
        ];

        // Apply security globally if configured
        $secType = $cfg['security']['type'] ?? 'bearer';
        if ($secType) {
            $spec['security'] = [['papyrus_auth' => []]];
        }

        return $spec;
    }

    /**
     * Build OpenAPI paths from grouped schema.
     */
    protected function buildPaths($schema, array $cfg): array
    {
        $paths = [];
        $excludeMethods = array_map('strtolower', $cfg['exclude_http_methods'] ?? []);
        $deleteWithBody = $cfg['delete_with_body'] ?? false;
        $defaultResponses = $cfg['responses'] ?? [];

        foreach ($schema as $group) {
            $groupName = is_array($group) ? ($group['name'] ?? 'General') : (is_object($group) ? ($group->name ?? 'General') : 'General');
            $routes = is_array($group) ? ($group['routes'] ?? []) : (is_object($group) ? ($group->routes ?? []) : []);

            foreach ($routes as $route) {
                foreach ($route->methods as $method) {
                    $m = strtolower($method);
                    if (in_array($m, $excludeMethods)) continue;
                    if ($m === 'head') continue; // HEAD is implicit with GET

                    $uri = '/' . ltrim($route->uri, '/');

                    // Convert Laravel {param} to OpenAPI {param}
                    $uri = preg_replace('/\{(\w+)\?\}/', '{$1}', $uri);

                    $operation = [
                        'tags'        => [$groupName],
                        'summary'     => $route->title ?? '',
                        'description' => $route->description ?? '',
                        'operationId' => $this->operationId($m, $route->uri),
                        'parameters'  => $this->extractPathParams($route->uri),
                        'responses'   => $this->buildResponses($route, $defaultResponses),
                    ];

                    // Request body (skip for GET, and for DELETE unless configured)
                    $hasBody = !in_array($m, ['get', 'head']);
                    if ($m === 'delete' && !$deleteWithBody) $hasBody = false;

                    if ($hasBody && !empty($route->bodyParams)) {
                        $operation['requestBody'] = $this->buildRequestBody($route->bodyParams);
                    }

                    $paths[$uri][$m] = $operation;
                }
            }
        }

        return $paths;
    }

    /**
     * Extract path parameters from URI.
     */
    protected function extractPathParams(string $uri): array
    {
        $params = [];
        preg_match_all('/\{(\w+)\??}/', $uri, $matches);

        foreach ($matches[1] as $i => $name) {
            $optional = str_contains($matches[0][$i], '?');
            $params[] = [
                'name'     => $name,
                'in'       => 'path',
                'required' => !$optional,
                'schema'   => ['type' => 'string'],
            ];
        }

        return $params;
    }

    /**
     * Build request body from enriched schema nodes.
     */
    protected function buildRequestBody($bodyParams): array
    {
        $properties = [];
        $required = [];
        $hasFile = false;

        $nodes = is_array($bodyParams) ? $bodyParams : [];

        foreach ($nodes as $node) {
            $key = is_array($node) ? ($node['key'] ?? '') : (is_object($node) ? ($node->key ?? '') : '');
            if (!$key) continue;

            $prop = $this->nodeToSchema($node);
            $properties[$key] = $prop;

            $isRequired = is_array($node) ? ($node['required'] ?? false) : (is_object($node) ? ($node->required ?? false) : false);
            if ($isRequired) $required[] = $key;

            $type = is_array($node) ? ($node['type'] ?? 'text') : (is_object($node) ? ($node->type ?? 'text') : 'text');
            if ($type === 'file') $hasFile = true;
        }

        $contentType = $hasFile ? 'multipart/form-data' : 'application/json';

        $body = [
            'content' => [
                $contentType => [
                    'schema' => [
                        'type'       => 'object',
                        'properties' => $properties,
                    ],
                ],
            ],
        ];

        if (!empty($required)) {
            $body['content'][$contentType]['schema']['required'] = $required;
        }

        return $body;
    }

    /**
     * Convert a schema node to an OpenAPI property.
     */
    protected function nodeToSchema($node): array
    {
        $type = is_array($node) ? ($node['type'] ?? 'text') : (is_object($node) ? ($node->type ?? 'text') : 'text');
        $desc = is_array($node) ? ($node['description'] ?? '') : (is_object($node) ? ($node->description ?? '') : '');

        $prop = match ($type) {
            'number', 'integer' => ['type' => 'number'],
            'boolean'           => ['type' => 'boolean'],
            'email'             => ['type' => 'string', 'format' => 'email'],
            'url'               => ['type' => 'string', 'format' => 'uri'],
            'date'              => ['type' => 'string', 'format' => 'date'],
            'password'          => ['type' => 'string', 'format' => 'password'],
            'uuid'              => ['type' => 'string', 'format' => 'uuid'],
            'file'              => ['type' => 'string', 'format' => 'binary'],
            'color'             => ['type' => 'string', 'format' => 'color'],
            'json'              => ['type' => 'object'],
            'array'             => ['type' => 'array', 'items' => ['type' => 'string']],
            'object'            => ['type' => 'object'],
            'select'            => ['type' => 'string'],
            default             => ['type' => 'string'],
        };

        if ($desc) $prop['description'] = $desc;

        // Min/max constraints
        $min = is_array($node) ? ($node['min'] ?? null) : (is_object($node) ? ($node->min ?? null) : null);
        $max = is_array($node) ? ($node['max'] ?? null) : (is_object($node) ? ($node->max ?? null) : null);
        if ($min !== null) $prop['minimum'] = $min;
        if ($max !== null) $prop['maximum'] = $max;

        // Pattern constraint
        $pattern = is_array($node) ? ($node['pattern'] ?? null) : (is_object($node) ? ($node->pattern ?? null) : null);
        if ($pattern) $prop['pattern'] = $pattern;

        // Options → enum
        $options = is_array($node) ? ($node['options'] ?? null) : (is_object($node) ? ($node->options ?? null) : null);
        if ($options && is_array($options)) $prop['enum'] = $options;

        // Accept for files
        $accept = is_array($node) ? ($node['accept'] ?? null) : (is_object($node) ? ($node->accept ?? null) : null);
        if ($accept && $type === 'file') $prop['description'] = ($desc ? "$desc. " : '') . "Accepted: $accept";

        // Nested object schema
        $schema = is_array($node) ? ($node['schema'] ?? null) : (is_object($node) ? ($node->schema ?? null) : null);
        if ($type === 'object' && $schema && is_array($schema)) {
            $nested = [];
            foreach ($schema as $child) {
                $childKey = is_array($child) ? ($child['key'] ?? '') : ($child->key ?? '');
                if ($childKey) $nested[$childKey] = $this->nodeToSchema($child);
            }
            if ($nested) $prop['properties'] = $nested;
        }

        return $prop;
    }

    /**
     * Build response definitions.
     */
    protected function buildResponses($route, array $defaults): array
    {
        $responses = [];

        // 200 with actual response data if available
        $responses['200'] = [
            'description' => 'Successful response',
            'content' => [
                'application/json' => [
                    'schema' => [
                        'type' => 'object',
                        'example' => $route->response ?? null,
                    ],
                ],
            ],
        ];

        // Add default responses
        foreach ($defaults as $code => $def) {
            if ($code === '200') continue;
            $responses[(string) $code] = $def;
        }

        return $responses;
    }

    /**
     * Build components section (security schemes).
     */
    protected function buildComponents(array $cfg): array
    {
        $security = $cfg['security'] ?? [];
        $type = $security['type'] ?? 'bearer';

        $scheme = match ($type) {
            'bearer' => [
                'type'   => 'http',
                'scheme' => 'bearer',
                'bearerFormat' => 'JWT',
            ],
            'apiKey' => [
                'type' => 'apiKey',
                'in'   => $security['position'] ?? 'header',
                'name' => $security['name'] ?? 'api_key',
            ],
            'basic' => [
                'type'   => 'http',
                'scheme' => 'basic',
            ],
            default => [
                'type'   => 'http',
                'scheme' => 'bearer',
            ],
        };

        return [
            'securitySchemes' => [
                'papyrus_auth' => $scheme,
            ],
        ];
    }

    /**
     * Generate a unique operation ID from method + URI.
     */
    protected function operationId(string $method, string $uri): string
    {
        $slug = preg_replace('/[^a-zA-Z0-9]/', '_', $uri);
        return $method . '_' . trim($slug, '_');
    }
}
