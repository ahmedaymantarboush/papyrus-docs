<?php

namespace AhmedTarboush\PapyrusDocs\Exporters;

/**
 * PostmanGenerator â€” Converts the Papyrus internal schema into
 * a valid Postman Collection v2.1.0 JSON format.
 *
 * Features:
 *   - Grouped into Postman Folders by API group
 *   - Default headers from config('papyrus.default_headers')
 *   - Mock request body generated from validation schema
 *   - Path parameter variables with Postman {{var}} syntax
 *   - Proper method, URL, and description mapping
 */
class PostmanGenerator
{
    /**
     * Generate a Postman Collection v2.1.0.
     *
     * @param  mixed  $schema  The grouped routes collection
     * @return array  Postman collection array
     */
    public function generate($schema): array
    {
        $defaultHeaders = config('papyrus.default_headers', []);
        $serverUrl = config('papyrus.open_api.server_url', config('app.url', 'http://localhost'));

        return [
            'info' => [
                'name'        => config('papyrus.title', config('app.name') . ' API'),
                'description' => config('papyrus.open_api.description', 'Auto-generated by Papyrus Docs.'),
                '_postman_id' => \Illuminate\Support\Str::uuid()->toString(),
                'schema'      => 'https://schema.getpostman.com/json/collection/v2.1.0/collection.json',
            ],
            'item' => $this->buildFolders($schema, $defaultHeaders, $serverUrl),
        ];
    }

    /**
     * Build Postman folder items from grouped schema.
     */
    protected function buildFolders($schema, array $defaultHeaders, string $serverUrl): array
    {
        $folders = [];

        foreach ($schema as $group) {
            $groupName = is_array($group) ? ($group['name'] ?? 'General') : (is_object($group) ? ($group->name ?? 'General') : 'General');
            $routes = is_array($group) ? ($group['routes'] ?? []) : (is_object($group) ? ($group->routes ?? []) : []);

            $items = [];
            foreach ($routes as $route) {
                $method = $route->methods[0] ?? 'GET';
                $items[] = [
                    'name'    => $route->title ?? $route->uri,
                    'request' => $this->buildRequest($route, $method, $defaultHeaders, $serverUrl),
                ];
            }

            $folders[] = [
                'name' => $groupName,
                'item' => $items,
            ];
        }

        return $folders;
    }

    /**
     * Build a single Postman request.
     */
    protected function buildRequest($route, string $method, array $defaultHeaders, string $serverUrl): array
    {
        $request = [
            'method'      => strtoupper($method),
            'description' => $route->description ?? '',
            'header'      => $this->buildHeaders($defaultHeaders),
            'url'         => $this->buildUrl($route->uri, $serverUrl),
        ];

        // Add body for non-GET/HEAD methods
        if (!in_array(strtoupper($method), ['GET', 'HEAD']) && !empty($route->bodyParams)) {
            $request['body'] = $this->buildBody($route->bodyParams);
        }

        return $request;
    }

    /**
     * Build Postman headers array.
     */
    protected function buildHeaders(array $defaultHeaders): array
    {
        $headers = [];
        foreach ($defaultHeaders as $key => $value) {
            $headers[] = [
                'key'   => $key,
                'value' => $value,
                'type'  => 'text',
            ];
        }
        return $headers;
    }

    /**
     * Build Postman URL object with path parameters.
     */
    protected function buildUrl(string $uri, string $serverUrl): array
    {
        $parsed = parse_url($serverUrl);
        $host = $parsed['host'] ?? 'localhost';
        $protocol = $parsed['scheme'] ?? 'https';
        $port = isset($parsed['port']) ? (string) $parsed['port'] : '';

        // Convert Laravel {param} and {param?} to Postman :param
        $pathStr = preg_replace('/\{(\w+)\??\}/', ':$1', $uri);
        $path = array_filter(explode('/', $pathStr));

        // Extract variables
        $variables = [];
        preg_match_all('/\{(\w+)\??\}/', $uri, $matches);
        foreach ($matches[1] as $param) {
            $variables[] = [
                'key'         => $param,
                'value'       => '',
                'description' => "Path parameter: $param",
            ];
        }

        $url = [
            'raw'      => "$protocol://$host" . ($port ? ":$port" : '') . "/$pathStr",
            'protocol' => $protocol,
            'host'     => explode('.', $host),
            'path'     => array_values($path),
        ];

        if ($port) $url['port'] = $port;
        if (!empty($variables)) $url['variable'] = $variables;

        return $url;
    }

    /**
     * Build Postman request body with mock data from schema.
     */
    protected function buildBody($bodyParams): array
    {
        $nodes = is_array($bodyParams) ? $bodyParams : [];
        $hasFile = false;

        // Check for file fields
        foreach ($nodes as $node) {
            $type = is_array($node) ? ($node['type'] ?? 'text') : (is_object($node) ? ($node->type ?? 'text') : 'text');
            if ($type === 'file') {
                $hasFile = true;
                break;
            }
        }

        if ($hasFile) {
            return $this->buildFormDataBody($nodes);
        }

        return [
            'mode' => 'raw',
            'raw'  => json_encode($this->generateMockJson($nodes), JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE),
            'options' => [
                'raw' => [
                    'language' => 'json',
                ],
            ],
        ];
    }

    /**
     * Build form-data body for file uploads.
     */
    protected function buildFormDataBody(array $nodes): array
    {
        $data = [];
        foreach ($nodes as $node) {
            $key = is_array($node) ? ($node['key'] ?? '') : ($node->key ?? '');
            $type = is_array($node) ? ($node['type'] ?? 'text') : ($node->type ?? 'text');

            if ($type === 'file') {
                $data[] = ['key' => $key, 'type' => 'file', 'src' => ''];
            } else {
                $data[] = ['key' => $key, 'value' => $this->mockValueForType($type, $node), 'type' => 'text'];
            }
        }

        return ['mode' => 'formdata', 'formdata' => $data];
    }

    /**
     * Generate a realistic mock JSON object from schema nodes.
     */
    protected function generateMockJson(array $nodes): array
    {
        $mock = [];

        foreach ($nodes as $node) {
            $key = is_array($node) ? ($node['key'] ?? '') : ($node->key ?? '');
            $type = is_array($node) ? ($node['type'] ?? 'text') : ($node->type ?? 'text');
            $isList = is_array($node) ? ($node['isList'] ?? false) : ($node->isList ?? false);

            if (!$key) continue;

            if ($type === 'object') {
                $schema = is_array($node) ? ($node['schema'] ?? []) : ($node->schema ?? []);
                $mockObj = is_array($schema) ? $this->generateMockJson($schema) : new \stdClass();
                $mock[$key] = $isList ? [$mockObj] : $mockObj;
            } elseif ($type === 'array') {
                $mock[$key] = [];
            } else {
                $mock[$key] = $this->mockValueForType($type, $node);
            }
        }

        return $mock;
    }

    /**
     * Generate a realistic mock value based on field type and constraints.
     */
    protected function mockValueForType(string $type, $node): mixed
    {
        // Check for options first (enum/select)
        $options = is_array($node) ? ($node['options'] ?? null) : (is_object($node) ? ($node->options ?? null) : null);
        if (is_array($options) && count($options) > 0) {
            return $options[0]; // First option as default
        }

        return match ($type) {
            'email'      => 'user@example.com',
            'url'        => 'https://example.com',
            'number', 'integer' => 0,
            'boolean'    => true,
            'date'       => '2025-01-01',
            'password'   => 'password123',
            'color'      => '#FF5733',
            'uuid'       => '550e8400-e29b-41d4-a716-446655440000',
            'ulid'       => '01ARZ3NDEKTSV4RRFFQ69G5FAV',
            'ip', 'ipv4' => '192.168.1.1',
            'ipv6'       => '::1',
            'mac_address' => '00:1B:44:11:3A:B7',
            'json'       => '{}',
            'select'     => '',
            default      => 'string',
        };
    }
}
